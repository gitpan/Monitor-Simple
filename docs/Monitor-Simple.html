<html><head><title>Monitor::Simple</title>
<meta http-equiv="Content-Type" content="text/html; charset=ISO-8859-1" >

<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
BODY {
  background: white;
  color: black;
  font-family: arial,sans-serif;
  margin: 0;
  padding: 1ex;
}

A:link, A:visited {
  background: transparent;
  color: #006699;
}

A[href="#POD_ERRORS"] {
  background: transparent;
  color: #FF0000;
}

DIV {
  border-width: 0;
}

DT {
  margin-top: 1em;
  margin-left: 1em;
}

.pod { margin-right: 20ex; }

.pod PRE     {
  background: #eeeeee;
  border: 1px solid #888888;
  color: black;
  padding: 1em;
  white-space: pre;
}

.pod H1      {
  background: transparent;
  color: #006699;
  font-size: large;
}

.pod H1 A { text-decoration: none; }
.pod H2 A { text-decoration: none; }
.pod H3 A { text-decoration: none; }
.pod H4 A { text-decoration: none; }

.pod H2      {
  background: transparent;
  color: #006699;
  font-size: medium;
}

.pod H3      {
  background: transparent;
  color: #006699;
  font-size: medium;
  font-style: italic;
}

.pod H4      {
  background: transparent;
  color: #006699;
  font-size: medium;
  font-weight: normal;
}

.pod IMG     {
  vertical-align: top;
}

.pod .toc A  {
  text-decoration: none;
}

.pod .toc LI {
  line-height: 1.2em;
  list-style-type: none;
}

  /*]]>*/-->
</style>


</head>
<body class='pod'>
<!--
  generated by Pod::Simple::HTML v3.16,
  using Pod::Simple::PullParser v3.16,
  under Perl v5.014002 at Sat Jun  8 07:30:49 2013 GMT.

 If you want to change this HTML document, you probably shouldn't do that
   by changing it directly.  Instead, see about changing the calling options
   to Pod::Simple::HTML, and/or subclassing Pod::Simple::HTML,
   then reconverting this document from the Pod source.
   When in doubt, email the author of Pod::Simple::HTML for advice.
   See 'perldoc Pod::Simple::HTML' for more info.

-->

<!-- start doc -->
<a name='___top' class='dummyTopAnchor' ></a>

<div class='indexgroup'>
<ul   class='indexList indexList1'>
  <li class='indexItem indexItem1'><a href='#NAME'>NAME</a>
  <li class='indexItem indexItem1'><a href='#VERSION'>VERSION</a>
  <li class='indexItem indexItem1'><a href='#SYNOPSIS'>SYNOPSIS</a>
  <li class='indexItem indexItem1'><a href='#DESCRIPTION'>DESCRIPTION</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Configuration_file'>Configuration file</a>
    <li class='indexItem indexItem2'><a href='#Plugins'>Plugins</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Plugin%3A_check-url.pl'>Plugin: check-url.pl</a>
      <li class='indexItem indexItem3'><a href='#Plugin%3A_check-post.pl'>Plugin: check-post.pl</a>
      <li class='indexItem indexItem3'><a href='#Plugin%3A_check-get.pl'>Plugin: check-get.pl</a>
      <li class='indexItem indexItem3'><a href='#Plugin%3A_check-prg.pl'>Plugin: check-prg.pl</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Creating_your_own_plugins'>Creating your own plugins</a>
    <li class='indexItem indexItem2'><a href='#Notifiers'>Notifiers</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#Notifier%3A_copy-to-file'>Notifier: copy-to-file</a>
      <li class='indexItem indexItem3'><a href='#Notifier%3A_send-email'>Notifier: send-email</a>
      <li class='indexItem indexItem3'><a href='#Notifier%3A_send-email-via-ssh'>Notifier: send-email-via-ssh</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Creating_your_own_notifiers'>Creating your own notifiers</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#MODULES_and_METHODS'>MODULES and METHODS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Monitor%3A%3ASimple'>Monitor::Simple</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#check_services_(%24args)'>check_services ($args)</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Monitor%3A%3ASimple%3A%3AConfig'>Monitor::Simple::Config</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#resolve_config_file_(%24filename)'>resolve_config_file ($filename)</a>
      <li class='indexItem indexItem3'><a href='#get_config_(%5B%24filename%5D)'>get_config ([$filename])</a>
      <li class='indexItem indexItem3'><a href='#extract_service_config_(%24service_id%2C_%24config)'>extract_service_config ($service_id, $config)</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Monitor%3A%3ASimple%3A%3AUserAgent'>Monitor::Simple::UserAgent</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#head_or_exit_(%24service_id%2C_%24config)'>head_or_exit ($service_id, $config)</a>
      <li class='indexItem indexItem3'><a href='#post_or_exit_(%24service_id%2C_%24config)'>post_or_exit ($service_id, $config)</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Monitor%3A%3ASimple%3A%3AOutput'>Monitor::Simple::Output</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#new_(%25args)'>new (%args)</a>
      <li class='indexItem indexItem3'><a href='#list_formats'>list_formats</a>
      <li class='indexItem indexItem3'><a href='#out_(%24service_id%2C_%24code%2C_%24message)'>out ($service_id, $code, $message)</a>
      <li class='indexItem indexItem3'><a href='#header_(%5B%24header%5D)'>header ([$header])</a>
      <li class='indexItem indexItem3'><a href='#footer_(%5B%24footer%5D)'>footer ([$footer])</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Monitor%3A%3ASimple%3A%3ANotifier'>Monitor::Simple::Notifier</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#new_(%25args)'>new (%args)</a>
      <li class='indexItem indexItem3'><a href='#notify_(%24result)'>notify ($result)</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Monitor%3A%3ASimple%3A%3ALog'>Monitor::Simple::Log</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#log_init_(%24logging_options)'>log_init ($logging_options)</a>
      <li class='indexItem indexItem3'><a href='#get_logging_options'>get_logging_options</a>
    </ul>
    <li class='indexItem indexItem2'><a href='#Monitor%3A%3ASimple%3A%3AUtils'>Monitor::Simple::Utils</a>
    <ul   class='indexList indexList3'>
      <li class='indexItem indexItem3'><a href='#parse_plugin_args_(%24default_service_id%2C_%40args)'>parse_plugin_args ($default_service_id, @args)</a>
      <li class='indexItem indexItem3'><a href='#report_and_exit_(%24service_id%2C_%24config%2C_%24exit_code%2C_%24return_msg)'>report_and_exit ($service_id, $config, $exit_code, $return_msg)</a>
      <li class='indexItem indexItem3'><a href='#exec_or_exit_(%24service_id%2C_%24config)'>exec_or_exit ($service_id, $config)</a>
      <li class='indexItem indexItem3'><a href='#parse_notifier_args_(%24args)'>parse_notifier_args ($args)</a>
    </ul>
  </ul>
  <li class='indexItem indexItem1'><a href='#BUGS'>BUGS</a>
  <ul   class='indexList indexList2'>
    <li class='indexItem indexItem2'><a href='#Known_bugs_and_limitations'>Known bugs and limitations</a>
  </ul>
  <li class='indexItem indexItem1'><a href='#ACKNOWLEDGMENT'>ACKNOWLEDGMENT</a>
  <li class='indexItem indexItem1'><a href='#AUTHOR'>AUTHOR</a>
  <li class='indexItem indexItem1'><a href='#COPYRIGHT_AND_LICENSE'>COPYRIGHT AND LICENSE</a>
</ul>
</div>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="NAME"
>NAME</a></h1>

<p>Monitor::Simple - Simple monitoring of applications and services</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="VERSION"
>VERSION</a></h1>

<p>version 0.2.8</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="SYNOPSIS"
>SYNOPSIS</a></h1>

<pre>   # check services defined in &#39;my.cfg&#39; and report to the STDOUT
   use Monitor::Simple;
   my $args = { config_file =&#62; &#39;my.cfg&#39; };
   Monitor::Simple-&#62;check_services ($args);

   It displays something like this:

   DATE                           SERVICE           STATUS  MESSAGE
   Tue Sep 20 12:15:00 2011       Memory Check           1  Memory WARNING - 70.7% (1064960 kB) used
   Tue Sep 20 12:15:01 2011       NCBI PubMed page       0  OK

   --- or using a ready-to-use script:

   smonitor -cfg my.cfg</pre>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="DESCRIPTION"
>DESCRIPTION</a></h1>

<p>The <b>Monitor::Simple</b> allows simple monitoring of applications and services of your IT infrastructure. There are many such tools, some of them very complex and sophisticated. For example, one widely used is <i>Nagios</i> (<a href="http://www.nagios.org/" class="podlinkurl"
>http://www.nagios.org/</a>). The <i>Monitor::Simple</i> does not aim, as its name indicates, for all features provided by those tools. It allows, however, to check whether your applications and services are running correctly. Its simple command-line interface can be used in cron jobs and reports can be viewed as a single HTML or text page.</p>

<p>Regarding <b>what</b> it checks, it uses the same concept as <i>Nagios</i>: all checking is done by <b>plugins</b>, standalone scripts. And more to it: these plugins are fully compatible with the Nagios plugins. Which means that you either write your own plugins and use them either with <i>Monitor::Simple</i> or with <i>Nagios</i>, or you can use many existing Nagios plugins and use them directly with the <i>Monitor::Simple</i>. For example, the &#34;Memory check&#34; in the synopsis above is an unchanged Nagios plugin.</p>

<p>Another concept used by <i>Monitor::Simple</i> are <b>notifiers</b>. These are again standalone scripts that are called whenever a service/application check is done and there is a notifier (or notifiers) defined to be used. The notification can be sent (or ignored) for every possible check result (errors, OK, all, etc.). Because these <i>notifiers</i> are just standalone scripts, one can easily wrapped many existing notifying tools (pagers, SMS senders, etc.); again, many of them are known to Nagios and similar programs.</p>

<p>Finally, the last &#34;concept&#34; in <i>Monitor::Simple</i> is the configuration. The Monitor::Simple uses an <b>XML configuration file</b> defining what services should be checked, how to check them (meaning, what plugins to use) and whom to notify (meaning, what notifiers to use). You can use Monitor::Simple without any Perl programming, just by creating a configuration file (because only you know what services you wish to check) and use it with the provided ready-to-use script <b>smonitor</b>, providing that the few plugins and notifiers distributed with Monitor::Simple are good enough (at least as a starting point). The <i>smonitor</i> has its own documentation describing its command-line parameters in details:</p>

<pre>   smonitor -man</pre>

<p>However, either way (using <i>smonitor</i> or embedding <i>Monitor::Simple</i> into your Perl code), you need to write a configuration file. So, let&#39;s start with it:</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Configuration_file"
>Configuration file</a></h2>

<p>The simplest configuration file is:</p>

<pre>   &#60;smon/&#62;</pre>

<p>It does nothing but also it does not complain. Even the root tag <code>smon</code> can be anything. But let&#39;s talk about more useful configuration files. They have a <code>general</code> section and a list of services to be checked in <code>services</code> section:</p>

<pre>   &#60;smon&#62;
     &#60;general&#62;&#60;/general&#62;
     &#60;services&#62;&#60;/services&#62;
   &#60;/smon&#62;</pre>

<p>However, it still does nothing. We need to add some services. Each service must have its <code>id</code> attribute and a <code>plugin</code> section where must be a <code>command</code> attribute:</p>

<pre>   &#60;smon&#62;
     &#60;services&#62;
       &#60;service id=&#34;service1&#34;&#62;
         &#60;plugin command=&#34;get-date.pl&#34; /&#62;
       &#60;/service&#62;
     &#60;/services&#62;
   &#60;/smon&#62;</pre>

<p>This configuration file, finally, does something. It invokes the plugin script <code>get-date.pl</code>. The script only returns the current date (so it does not do much of the checking) but it returns it in compatible way with all other plugins (also with Nagios plugins). It is good for testing. Here is how it reports (assuming that we named our configuration file <code>my.cfg</code>):</p>

<pre>   $&#62; smonitor -cfg my.cfg
   DATE                           SERVICE   STATUS  MESSAGE
   Tue Sep 20 14:05:29 2011       service1       0  Tue Sep 20 14:05:29 2011</pre>

<p>The <code>service</code> tag can also have a <code>name</code> attribute for a more human readable display name and a <code>description</code> tag (used in the HTML format of reports). The <code>plugin</code> tag can also have (and usually it has) more sub-tags. They varies depending on the plugin&#39;s command. Generally, all additional arguments for a plugin can be defined by the <code>args</code> and <code>arg</code> tags. They simply specify what will get the plugin on its command-line. For example, the Nagios plugin for checking available memory accepts these arguments:</p>

<pre>   &#60;smon&#62;
     &#60;services&#62;
       &#60;service id=&#34;memory&#34; name=&#34;Memory Check&#34;&#62;
         &#60;plugin command=&#34;check_mem.pl&#34;&#62;
           &#60;args&#62;
             &#60;arg&#62;-u&#60;/arg&#62; &#60;!-- check USED memory --&#62;
             &#60;arg&#62;-w&#60;/arg&#62; &#60;!-- -w PERCENT   Percent free/used when to warn --&#62;
             &#60;arg&#62;55&#60;/arg&#62;
             &#60;arg&#62;-c&#60;/arg&#62; &#60;!-- -c PERCENT   Percent free/used when critical --&#62;
             &#60;arg&#62;80&#60;/arg&#62;
           &#60;/args&#62;
         &#60;/plugin&#62;
       &#60;/service&#62;
     &#60;/services&#62;
   &#60;/smon&#62;

   $&#62; smonitor -cfg my.cfg
   DATE                       SERVICE       STATUS  MESSAGE
   Tue Sep 20 14:23:09 2011   Memory Check       1  Memory WARNING - 66.5% (893584 kB) used</pre>

<p>Read more about specific tags for plugins distributed with <i>Monitor::Simple</i> in the <a href="#Plugins" class="podlinkpod"
>&#34;Plugins&#34;</a> section.</p>

<p>Each service can also have one or more notifiers. Each notifier (see <a href="#Notifiers" class="podlinkpod"
>&#34;Notifiers&#34;</a>) is an external script defined by the <code>command</code> attribute. The script will be executed if the attribute <code>on</code> is satisfied. The <code>on</code> attribute contains a code or a comma-separated list of codes representing the result of the service check. If the result matches the attribute value (or, in case of a list, any of the values), the notifier is invoked. If you need to use the codes in your Perl programming, they are available as constants <i>Monitor::Simple::NOTIFY_*</i>. The code values in the configuration files are these:</p>

<pre>    NOTIFY_OK       =&#62; &#39;ok&#39;,
    NOTIFY_WARNING  =&#62; &#39;w&#39;,
    NOTIFY_CRITICAL =&#62; &#39;c&#39;,
    NOTIFY_UNKNOWN  =&#62; &#39;u&#39;,
    NOTIFY_ALL      =&#62; &#39;all&#39;,
    NOTIFY_ERRORS   =&#62; &#39;err&#39;,
    NOTIFY_NONE     =&#62; &#39;none&#39;,</pre>

<p>There are few other attributes and sub-tags for notifiers, such as <i>whom</i> the notification should be sent to. They depend on the type of the notifier - read more about specific attributes and tags for notifiers distributed with <i>Monitor::Simple</i> in the <a href="#Notifiers" class="podlinkpod"
>&#34;Notifiers&#34;</a> section. Here is an example of a service with two configured notifiers:</p>

<pre>   &#60;smon&#62;
     &#60;services&#62;
       &#60;service id=&#34;date&#34;&#62;
         &#60;plugin command=&#34;get-date.pl&#34; /&#62;
         &#60;notifier command=&#34;send-email&#34;   on=&#34;err&#34; email=&#34;senger@localhost&#34; /&#62;
         &#60;notifier command=&#34;copy-to-file&#34; on=&#34;all&#34;&#62;
           &#60;args&#62;
             &#60;arg&#62;-file&#60;/arg&#62; &#60;arg&#62;report.txt&#60;/arg&#62;
           &#60;/args&#62;
         &#60;/notifier&#62;
       &#60;/service&#62;
     &#60;/services&#62;
   &#60;/smon&#62;</pre>

<p>Each notifier can also have an attribute <code>format</code> specifying the format of the notification. The formats are &#34;tsv&#34; (TAB-separated values), &#34;html&#34; and &#34;human&#34; (plain text). But read about pitfalls of some of these formats in the <a href="#Notifiers" class="podlinkpod"
>&#34;Notifiers&#34;</a> section.</p>

<p>Finally, the notifiers can be also specified in the <code>general</code> section of the configuration file. These notifiers are then used for every service (additionally to the notifiers defined in individual services):</p>

<pre>   &#60;smon&#62;
     &#60;general&#62;
       &#60;notifier command=&#34;copy-to-file&#34; on=&#34;all&#34; format=&#34;tsv&#34;&#62;
         &#60;args&#62;
           &#60;arg&#62;-file&#60;/arg&#62; &#60;arg&#62;report.tsv&#60;/arg&#62;
         &#60;/args&#62;
       &#60;/notifier&#62;
     &#60;/general&#62;
     ...
   &#60;/smon&#62;</pre>

<p>Sometimes, you have a service for which you wish to exclude (to ignore) the general notifiers (those defined in the <code>general</code> tag). In such case use the <code>ignore-general-notifiers</code> tag:</p>

<pre>   &#60;service id=&#34;ping-git&#34; name=&#34;Ping Git Repository&#34;&#62;
     &#60;ignore-general-notifiers /&#62;
     &#60;plugin command=&#34;check-ping&#34;&#62;
       &#60;args&#62;
          ...
       &#60;/args&#62;
     &#60;/plugin&#62;
   &#60;/service&#62;</pre>

<p>For exploring configuration, the <i>Monitor::Simple</i> distribution has directory <em>Monitor/Simple/configs</em> with few examples of configuration files.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Plugins"
>Plugins</a></h2>

<p>The plugins are external scripts that are invoked to do the real service checking. Each service has its plugin defined in the configuration file:</p>

<pre>   &#60;service id=&#34;service1&#34;&#62;
      &#60;plugin command=&#34;check-my-service.pl&#34; /&#62;
   &#60;/service&#62;</pre>

<p>The plugins usually take some parameters - which are also specified in the configuration files (examples below).</p>

<p>Because plugins are just external scripts they can be anywhere on your machine. For such cases, you can use the full (absolute) path in the &#34;command&#34; attribute of the plugin. But usually, all (or most) plugins are in a single directory which you can specify in the &#34;general&#34; section of the configuration file:</p>

<pre>   &#60;general&#62;
      &#60;plugins-dir&#62;/some/directory/on/my/computer&#60;/plugins-dir&#62;
   &#60;/general&#62;</pre>

<p>Default location for all plugins is a directory &#34;plugins&#34; in the directory where sub-modules of Monitor::Simple are installed. Which means &#34;...somewhere/Monitor/Simple/plugins/&#34;.</p>

<p>There are several rather general plugins distributed with the <i>Monitor::Simple</i>:</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Plugin:_check-url.pl"
>Plugin: <b>check-url.pl</b></a></h3>

<p>A general plugin for checking availability of a single URL, using the <i>HTTP HEAD</i> method. You can use this plugin to check if the URL of your service or application is not broken, or/and if it returns within a specified timeout period. The configuration is the following:</p>

<pre>   &#60;plugin command=&#34;check-url.pl&#34;&#62;
     &#60;head-test&#62;
       &#60;url&#62;http://you.server.org/home/applications.php&#60;/url&#62;
       &#60;timeout&#62;5&#60;/timeout&#62;
     &#60;/head-test&#62;
     ... more &#60;head-test&#62;s can be here...
   &#60;/plugin&#62;</pre>

<p>The <code>url</code> tag is mandatory, the <code>timeout</code> tag is only optional. There may be more <code>head-test</code> sections if you wish to check more URLs by the same plugin call.</p>

<p>The plugin script is very simple; all the work is actually done by the method <code>Monitor::Simple::UserAgent-&#62;head_or_exit()</code>.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Plugin:_check-post.pl"
>Plugin: <b>check-post.pl</b></a></h3>

<p>This is a slightly generalized <a href="#Plugin%3A_check-url.pl" class="podlinkpod"
>check-url.pl</a> plugin. It can do also the <code>head-test</code>s (as the <code>check-url.pl</code> does) but its main purpose is to send data to the service using the <i>HTTP POST</i> method. It allows you to check whether your service returns expected data. The full configuration is the following:</p>

<pre>   &#60;plugin command=&#34;check-post.pl&#34;&#62;
     &#60;head-test&#62;
       &#60;url&#62;...&#60;/url&#62;
     &#60;/head-test&#62;
     &#60;post-test&#62;
       &#60;timeout&#62;5&#60;/timeout&#62;
       &#60;url&#62;...&#60;/url&#62;
       &#60;data&#62;&#60;![CDATA[name=brca1&#38;namespace=geneid&#38;format=html]]&#62;&#60;/data&#62;
       &#60;response&#62;
         &#60;content-type&#62;text/json&#60;/content-type&#62;
         &#60;contains&#62;BRCA1&#60;/contains&#62;
       &#60;/response&#62;
     &#60;/post-test&#62;
     &#60;post-test&#62;
       &#60;url&#62;&#60;/url&#62;
       &#60;data&#62;&#60;![CDATA[namespace=geneid&#38;action=table]]&#62;&#60;/data&#62;
       &#60;response&#62;
         &#60;content-type&#62;text/json&#60;/content-type&#62;
         &#60;contains&#62;Alternate_name&#60;/contains&#62;
         &#60;contains&#62;Gene_Symbol&#60;/contains&#62;
         &#60;equal&#62;...&#60;/equal&#62;
       &#60;/response&#62;
     &#60;/post-test&#62;
   &#60;/plugin&#62;</pre>

<p>At least one <code>post-test</code> section is mandatory, and it has to have a <code>url</code> and <code>data</code>. The response can be checked for the returned <i>HTTP Content type</i> or for text anywhere within the response body, or for equality (after trimming heading and trailing white-spaces). More <code>contains</code> tags means that all such texts must be found in the response body.</p>

<p>The plugin script is also simple; all the work is actually done by the method <code>Monitor::Simple::UserAgent-&#62;post_or_exit()</code>.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Plugin:_check-get.pl"
>Plugin: <b>check-get.pl</b></a></h3>

<p>This is very similar to <a href="#Plugin%3A_check-post.pl" class="podlinkpod"
>check-post.pl</a> plugin, except it uses <i>HTTP GET</i> method. And, therefore, it does not use <code>data</code> tag in the configuration file (because all input data are already part of the <code>url</code> tag). It does not use <i>HTTP HEAD</i> method.</p>

<p>Again, it allows you to check whether your service returns expected data. The full configuration is the following:</p>

<pre>   &#60;plugin command=&#34;check-get.pl&#34;&#62;
     &#60;get-test&#62;
       &#60;timeout&#62;5&#60;/timeout&#62;
       &#60;url&#62;![CDATA[...]]&#62;&#60;/url&#62;
       &#60;response&#62;
         &#60;content-type&#62;text/json&#60;/content-type&#62;
         &#60;contains&#62;...&#60;/contains&#62;
         &#60;equal&#62;...&#60;/equal&#62;
       &#60;/response&#62;
     &#60;/get-test&#62;
     &#60;get-test&#62;
        ...
     &#60;/get-test&#62;
   &#60;/plugin&#62;</pre>

<p>At least one <code>get-test</code> section is mandatory, and it has to have a <code>url</code>. The response can be checked for the returned <i>HTTP Content type</i> or for text anywhere within the response body, or for equality (after trimming heading and trailing white-spaces). More <code>contains</code> tags means that all such texts must be found in the response body.</p>

<p>The plugin script is also simple; all the work is actually done by the method <code>Monitor::Simple::UserAgent-&#62;get_or_exit()</code>.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Plugin:_check-prg.pl"
>Plugin: <b>check-prg.pl</b></a></h3>

<p>A general plugin that executes any command-line program with the given arguments and then it reports warning if there was any STDERR and it checks the STDOUT for expected values. The full configuration is the following:</p>

<pre>   &#60;plugin command=&#34;check-prg.pl&#34;&#62;
     &#60;prg-test&#62;
       &#60;program&#62;...&#60;/program&#62;
       &#60;timeout&#62;...&#60;/timeout&#62;
       &#60;args&#62;
         &#60;arg&#62;...&#60;/arg&#62;
         &#60;arg&#62;...&#60;/arg&#62;
       &#60;/args&#62;
       &#60;stdout&#62;
         &#60;contains&#62;...&#60;/contains&#62;
         &#60;contains&#62;...&#60;/contains&#62;
       &#60;/stdout&#62;
     &#60;/prg-test&#62;
     &#60;prg-test&#62;
       &#60;program&#62;...&#60;/program&#62;
       &#60;timeout&#62;...&#60;/timeout&#62;
       &#60;args&#62;
         &#60;arg&#62;...&#60;/arg&#62;
       &#60;/args&#62;
       &#60;stdout&#62;
         &#60;is-integer/&#62;
       &#60;/stdout&#62;
     &#60;/prg-test&#62;
   &#60;/plugin&#62;</pre>

<p>At least one <code>prg-test</code> section is mandatory, and it has to have a <code>program</code> tag (a program that will be invoked). The STDOUT of the invoked program can be checked that it contains given text. More <code>contains</code> tags means that all such texts must be present. It can also make a test that the produced STDOUT is nothing than white-spaces and an integer.</p>

<p>The <code>timeout</code> tag may specify how many seconds to wait for the program completion before it reports timeout warning.</p>

<p>Again, the plugin script is simple; all the work is actually done by the method <code>Monitor::Simple::Utils-&#62;exec_or_exit()</code>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Creating_your_own_plugins"
>Creating your own plugins</a></h2>

<p>Plugins are executed from inside of the main method <code>Monitor::Simple-&#62;check_services()</code>. The method creates one of the two possible types of command-line. One is used for native <i>Monitor::Simple</i> plugins. This type is created if there are no <code>arg</code> tags in the plugin configuration:</p>

<pre>   &#60;plugin-command&#62; -service &#60;id&#62;              \
                    -cfg &#60;config-file&#62;         \
                    -logfile &#60;logfile&#62;         \
                    -loglevel &#60;level&#62;          \
                    -logformat &#60;format&#62;</pre>

<p>The <code>service id</code> identifies what service this plugin was invoked for. The <code>-cfg config-file</code> contains a filename with the XML configuration. From this file, you can get the full configuration by using:</p>

<pre>   my $config = Monitor::Simple::Config-&#62;get_config ($config_file);</pre>

<p>All command-line arguments can be parsed by calling <code>Monitor::Simple::Utils-&#62;parse_plugin_args()</code>. Therefore, the <i>Monitor::Simple</i> native plugin scripts usually start with:</p>

<pre>   use Monitor::Simple;
   use Log::Log4perl qw(:easy);

   # read command-line arguments and configuration
   my ($config_file, $service_id) = Monitor::Simple::Utils-&#62;parse_plugin_args (&#39;&#39;, @ARGV);
   LOGDIE (&#34;Unknown service (missing parameter &#39;-service &#60;id&#62;&#39;)\n&#34;)
      unless $service_id;
   my $config = Monitor::Simple::Config-&#62;get_config ($config_file);</pre>

<p>As you see in this example, you can use the logging system by calling <code>Log::Log4perl</code> so-called &#34;easy&#34; methods: DEBUG(), INFO(), WARN(), ERROR(), LOGDIE() and LOGWARN(), without doing anything with the log-related arguments.</p>

<p>If the plugin configuration contains <code>arg</code> tags, then the plugin will be invoked with the command-line exactly as defined by these <code>args</code> tags. This is how to use plugins written without <i>Monitor::Simple</i> support. An example is the Nagios plugin &#34;check-mem.pl&#34;. Its configuration looks like this:</p>

<pre>   &#60;plugin command=&#34;check_mem.pl&#34;&#62;
      &#60;args&#62;
         &#60;arg&#62;-u&#60;/arg&#62;
         &#60;arg&#62;-w&#60;/arg&#62; &#60;arg&#62;75&#60;/arg&#62;
         &#60;arg&#62;-c&#60;/arg&#62; &#60;arg&#62;80&#60;/arg&#62;
      &#60;/args&#62;
   &#60;/plugin&#62;</pre>

<p>and it will be called with this command-line:</p>

<pre>   check_mem.pl -u -w 75 -c 80</pre>

<p>Regarding the results, each plugin is expected to comply with the Nagios plugins standard <a href="http://nagios.sourceforge.net/docs/3_0/pluginapi.html" class="podlinkurl"
>http://nagios.sourceforge.net/docs/3_0/pluginapi.html</a> which means:</p>

<dl>
<dt><a name="Exit_code"
><b>Exit code</b></a></dt>

<dd>
<p>The exit code should be zero for success and 1, 2 or 3 when the checking failed:</p>

<pre>   Exit code   Service State
      0           OK
      1           WARNING
      2           CRITICAL
      3           UNKNOWN</pre>

<p>In your programming you may use the predefined constants in <i>Monitor::Simple</i> module:</p>

<pre>   use constant {
      RETURN_OK       =&#62; 0,
      RETURN_WARNING  =&#62; 1,
      RETURN_CRITICAL =&#62; 2,
      RETURN_UNKNOWN  =&#62; 3,
   }</pre>

<dt><a name="STDOUT"
><b>STDOUT</b></a></dt>

<dd>
<p>The output can be a single line of text (which is mandatory), or it can be more lines (they are optional).</p>

<pre>   TEXT OUTPUT
   LONG TEXT LINE 1
   LONG TEXT LINE 2
   ...
   LONG TEXT LINE N</pre>

<p>Additionally, the first and the last line can be extended by &#34;performance data&#34; separated by a bar (&#34;|&#34;) character:</p>

<pre>   TEXT OUTPUT | OPTIONAL PERFDATA
   LONG TEXT LINE 1
   LONG TEXT LINE 2
   ...
   LONG TEXT LINE N | PERFDATA LINE 2
   PERFDATA LINE 3
   ...
   PERFDATA LINE N</pre>

<p>The <i>Monitor::Simple</i> does not do anything special with the performance data, it just leaves them in the report. But you should be aware of it and not to use bar characters in the output of your plugins.</p>
</dd>
</dl>

<p>The <i>Monitor::Simple</i> provides few methods that can be useful in your plugins. For example, for checking availability of a URL or for checking contents of a checked web page. See the distributed plugins (and their documentation above) for more details.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Notifiers"
>Notifiers</a></h2>

<p>The notifiers are external scripts that are called whenever a need for a notification occurs. The notifiers can be specified for individual services, or for all services (see examples in <a href="#Configuration_file" class="podlinkpod"
>&#34;Configuration file&#34;</a>).</p>

<p>Each notifier is used independently on other notifiers; there is no mechanism collecting them together and sending all notifications in one go. If you need a &#34;collective report&#34; (which you often do) for all services, use rather STDOUT produced by the <code>Monitor::Simple-&#62;check_services()</code> method. This method can be used in a program (do not forget the ready-to-use such program <code>smonitor</code>) that is called in a cron job - and the cron job itself takes care about sending an email with the full result, without any notifier. Sending email notifications by using notifiers is more fine-grained: with the notifiers you can send notifications to different email addresses for each service or a group of services.</p>

<p>Because of the independence of notifiers, some notification formats may be less convenient. You can use without problems the &#34;tsv&#34; (TAB-separated values) format because this format does not produce any header or footer lines. All such notifications can be, therefore, conveniently, appended to a single file keeping the full history of all checking. Other formats, such as &#34;html&#34;, are better used for not-so-frequent notifications, such as sending an email if a service failed.</p>

<p>A notifier is invoked only if the result of a service check matches the code in the <code>on</code> attribute of this notifier (again, see the <a href="#Configuration_file" class="podlinkpod"
>&#34;Configuration file&#34;</a>).</p>

<p>Because notifiers are just external scripts they can be anywhere on your machine. For such cases, you can use the full (absolute) path in the <code>command</code> attribute of the notifier. But usually, all (or most) notifiers are in a single directory which you can specify in the <code>general</code> section of the configuration file:</p>

<pre>   &#60;general&#62;
      &#60;notifiers-dir&#62;/some/directory/on/my/computer&#60;/notifiers-dir&#62;
   &#60;/general&#62;</pre>

<p>Default location for all notifiers is a directory <code>notifiers</code> in the directory where sub-modules of <i>Monitor::Simple</i> are installed. Which means <code>...somewhere/Monitor/Simple/notifiers/</code>. This is also the place where you can find the ready-to-use notifiers coming with the <i>Monitor::Simple</i> distribution. Each of them has slightly different needs for the configuration:</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Notifier:_copy-to-file"
>Notifier: <b>copy-to-file</b></a></h3>

<p>A notifier appending its notification to a file. Here is how to configure this notifier (either within the <code>service</code> tag or within the <code>general</code> tag):</p>

<pre>   &#60;notifier command=&#34;copy-to-file&#34; on=&#34;all&#34; format=&#34;tsv&#34;&#62;
      &#60;args&#62;
         &#60;arg&#62;-file&#60;/arg&#62;  &#60;arg&#62;report.tsv&#60;/arg&#62;
         &#60;arg&#62;-login&#60;/arg&#62; &#60;arg&#62;senger@allele&#60;/arg&#62;
      &#60;/args&#62;
   &#60;/notifier&#62;</pre>

<p>The mandatory <code>-file</code> argument specifies the name of a file (usually with the full path) where the notification will be appended. The argument <code>-login</code> allows to use a file on a remote machine, providing the SSH login name. This notifier does not have any provision for specifying a password. Therefore, the user from the <code>-login</code> argument must have its public key already installed on the remote machine.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Notifier:_send-email"
>Notifier: <b>send-email</b></a></h3>

<p>A notifier sending notification to one or more email addresses. Be aware that this could work only if your computer <b>can</b> send emails. If not check the following notifier &#34;send-email-via-ssh&#34;.</p>

<p>Configuration of this notifier uses either attribute <code>email</code> or <code>email-group</code> or both. Each of this attributes can have one or more, comma-separated, values. Examples are:</p>

<pre>   &#60;notifier command=&#34;send-email&#34; on=&#34;err&#34; email=&#34;senger@localhost&#34; /&#62;
   &#60;notifier command=&#34;send-email&#34; on=&#34;err&#34; email=&#34;senger@localhost,kim@localhost&#34; /&#62;
   &#60;notifier command=&#34;send-email&#34; on=&#34;err&#34; email-group=&#34;watch-dogs&#34; /&#62;
   &#60;notifier command=&#34;send-email&#34; on=&#34;err&#34; email-group=&#34;watch-dogs, others&#34; /&#62;
   &#60;notifier command=&#34;send-email&#34; on=&#34;err&#34; email-group=&#34;secrets&#34; email=&#34;senger@localhost&#34;/&#62;</pre>

<p>If you use the <code>email-group</code> attribute, you need also to tell what addresses this group contains. It is done in the <code>general</code> section. For example:</p>

<pre>   &#60;general&#62;
      &#60;email-group id=&#34;others&#34;&#62;
         &#60;email&#62;jitka@localhost&#60;/email&#62;
         &#60;email&#62;guest@localhost&#60;/email&#62;
      &#60;/email-group&#62;
      &#60;email-group id=&#34;secrets&#34;&#62;
         &#60;email&#62;top.secret@elsewhere.com&#60;/email&#62;
      &#60;/email-group&#62;
   &#60;/general&#62;</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="Notifier:_send-email-via-ssh"
>Notifier: <b>send-email-via-ssh</b></a></h3>

<p>This notifier does the same as the previous <i>send-email</i> except that it first logs-in to a remote machine using SSH and executes the <code>mail</code> command there. It is useful when your computer cannot directly send emails - but it requires that you have an SSH account somewhere and that machine has your SSH public key installed (there is no provision for specifying a password in this notifier configuration).</p>

<p>The configuration attributes for this notifier are the same as for <code>send-email</code> (except the different name of the command) and additionally it has the <code>-login</code> argument:</p>

<pre>   &#60;notifier command=&#34;send-email-via-ssh&#34; on=&#34;err&#34; email=&#34;martin.senger@gmail.com&#34;&#62;
      &#60;args&#62;
         &#60;arg&#62;-login&#60;/arg&#62;
         &#60;arg&#62;senger@open-bio.org&#60;/arg&#62;
      &#60;/args&#62;
   &#60;/notifier&#62;</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Creating_your_own_notifiers"
>Creating your own notifiers</a></h2>

<p>The notifiers are invoked - whenever necessary - from inside of the main method <code>Monitor::Simple-&#62;check_services()</code>. The method creates the following command-line:</p>

<pre>   &#60;notifier-command&#62; -service &#60;id&#62;              \
                      -msg &#60;file&#62;                \
                      -emails email1 [email2...] \
                      -logfile &#60;logfile&#62;         \
                      -loglevel &#60;level&#62;          \
                      -logformat &#60;format&#62;        \
                      &#60;additional arguments&#62;</pre>

<p>where additional arguments comes from the configuration file from the <code>arg</code> tags specified for this notifier. The <code>service id</code> identifies what service this notifier was invoked for. The <code>-msg file</code> is a filename with already formatted notification message. Read this file but do not destroy it - other notifiers may want to read it, too. The <code>-emails...</code> may not be relevant to your notifier but if there were attributes <code>email</code> and/or <code>email-group</code> in the notifier configuration they are passed here.</p>

<p>All basic (not additional) arguments can be parsed by calling <code>Monitor::Simple::Utils-&#62;parse_notifier_args()</code>. Therefore, the notifier script usually starts with:</p>

<pre>   use Monitor::Simple;
   use Log::Log4perl qw(:easy);

   # read command-line arguments
   my ($service_id, $msgfile, $emails) = Monitor::Simple::Utils-&#62;parse_notifier_args (\@ARGV);</pre>

<p>You can continue by parsing the additional arguments (if any). Here is an example from <code>send-email-via-ssh</code> notifier:</p>

<pre>   # read more command-line arguments specific for this notifier
   my ($login_name);
   Getopt::Long::Configure (&#39;no_ignore_case&#39;, &#39;pass_through&#39;);
   GetOptionsFromArray (\@ARGV,
                        &#39;login=s&#39; =&#62; \$login_name,
                       );
   LOGDIE (&#34;Missing parameter &#39;-login&#39; with hostname or user\@hostname\n&#34;)
           unless $login_name;</pre>

<p>And then you do whatever your notifier needs to do. You can use the logging system by calling <code>Log::Log4perl</code> so-called &#34;easy&#34; methods: DEBUG(), INFO(), WARN(), ERROR(), LOGDIE() and LOGWARN().</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="MODULES_and_METHODS"
>MODULES and METHODS</a></h1>

<p>The best way to explore modules, methods and how to use them is to look the <i>smonitor</i> script. Here is a short summary what methods are available. The main focus is on methods helping to write your own plugins and notifiers.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Monitor::Simple"
>Monitor::Simple</a></h2>

<p>This module is a wrapper for all other modules and has only one, but important, method (it is a class method):</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="check_services_($args)"
>check_services ($args)</a></h3>

<p>It loops over all services and checks them (by invoking their plugins). If necessary, it invokes their notifiers. And it produces a summary report about all checks. The $args is a hashref with the following keys and values:</p>

<dl>
<dt><a name="config_file_-&#62;_$file"
>config_file -&#62; $file</a></dt>

<dd>
<p>A mandatory argument. It specifies what configuration to use.</p>

<dt><a name="outputter_=&#62;_an_instance_of_Monitor::Simple::Output"
>outputter =&#62; an instance of <i>Monitor::Simple::Output</i></a></dt>

<dd>
<p>This outputter will be responsible for creating the summary report of all checks. If not given, a default outputter is used.</p>

<dt><a name="filter_=&#62;_hashref_or_arrayref_or_scalar"
>filter =&#62; hashref or arrayref or scalar</a></dt>

<dd>
<p>If any filter given then it contains IDs of services that will be checked (and only them will be checked). Of course, it can still be only services that are defined in the configuration file.</p>

<p>The scalar is use if you need to check only one service. The arrayref points to a list of service IDs. The hashref has service IDs as keys (values are ignored).</p>

<dt><a name="nonotif_=&#62;_boolean"
>nonotif =&#62; boolean</a></dt>

<dd>
<p>If set to true all notifications (for all services) will be disabled. Default is false.</p>

<dt><a name="npp_=&#62;_integer"
>npp =&#62; integer</a></dt>

<dd>
<p>Maximum number of service checks done in parallel. Default is 10.</p>
</dd>
</dl>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Monitor::Simple::Config"
>Monitor::Simple::Config</a></h2>

<p>This module helps to find and explore the configuration file (that defines what should be monitored). There are no instances of this module (no <code>new</code> or similar method), all methods are class methods (but still methods - so use &#34;Monitor::Simple::Config-&#62;&#34; to call them).</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="resolve_config_file_($filename)"
>resolve_config_file ($filename)</a></h3>

<p>It tries to locate given $filename and return its full path:</p>

<dl>
<dt><a name="a)_as_it_is_-_if_such_file_exists"
>a) as it is - if such file exists</a></dt>

<dd>
<dt><a name="b)_as_$ENV{MONITOR_SIMPLE_CFG_DIR}/$filename"
>b) as $ENV{MONITOR_SIMPLE_CFG_DIR}/$filename</a></dt>

<dd>
<dt><a name="c)_in_the_directory_where_the_main_invoker_(e.g._your_program)_is_located"
>c) in the directory where the main invoker (e.g. your program) is located</a></dt>

<dd>
<dt><a name="d)_in_one_of_the_@INC_directories"
>d) in one of the @INC directories</a></dt>

<dd>
<dt><a name="e)_return_undef"
>e) return undef</a></dt>
</dl>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="get_config_([$filename])"
>get_config ([$filename])</a></h3>

<p>It reads configuration from a file and returns it as a hashref. The configuration is looked for in the given $filename or in a default configuration file name. The path to both given and default configuration file is resolved by rules defined in <a href="#resolve_config_file_(%24filename)" class="podlinkpod"
>resolve_config_file()</a>. The default configuration file name is in <code>$Monitor::Simple::DEFAULT_CONFIG_FILE</code>.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="extract_service_config_($service_id,_$config)"
>extract_service_config ($service_id, $config)</a></h3>

<p>Return a hashref with configuration for a given service (identified by its $service_id). If such configuration cannot be found, a warning is issued and undef is returned. The service configuration is looked for in the given hashref $config containing the full configuration (usually obtained by <a href="#get_config_(%5B%24filename%5D)" class="podlinkpod"
>get_config()</a>).</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Monitor::Simple::UserAgent"
>Monitor::Simple::UserAgent</a></h2>

<p>This module deals with the Web communication. It uses <i>LWP::UserAgent</i> module to do the communication. It uses only class methods.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="head_or_exit_($service_id,_$config)"
>head_or_exit ($service_id, $config)</a></h3>

<p>It makes the <i>HTTP HEAD</i> test described in <a href="#Plugin%3A_check-url.pl" class="podlinkpod"
>check_url.pl</a> plugin. If everything okay it just returns. Otherwise, it exits with the Nagios-compliant reporting (see more about it in <a href="#report_and_exit_(%24service_id%2C_%24config%2C_%24exit_code%2C_%24return_msg)" class="podlinkpod"
>report_and_exit()</a>).</p>

<p>This method uses <code>head-test</code> portion of this service configuration.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="post_or_exit_($service_id,_$config)"
>post_or_exit ($service_id, $config)</a></h3>

<p>It makes the <i>HTTP POST</i> test described in <a href="#Plugin%3A_check-post.pl" class="podlinkpod"
>check_post.pl</a> plugin. If everything okay it just returns. Otherwise, it exits with the Nagios-compliant reporting (see more about it in <a href="#report_and_exit_(%24service_id%2C_%24config%2C_%24exit_code%2C_%24return_msg)" class="podlinkpod"
>report_and_exit()</a>).</p>

<p>This method uses <code>post-test</code> portion of this service configuration.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Monitor::Simple::Output"
>Monitor::Simple::Output</a></h2>

<p>This module is responsible for outputting the results of service checks in several different formats. It is also used by notifiers to format their notification messages. The main method is <code>out()</code> that prints the given message in the given format to the given target, both as defined in the <code>new()</code> constructor method.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="new_(%args)"
>new (%args)</a></h3>

<p>It creates an instance (an <i>outputter</i>) with the given arguments. The recognized keys are:</p>

<dl>
<dt><a name="config_=&#62;_$config"
>config =&#62; $config</a></dt>

<dd>
<p>A configuration - the only mandatory argument.</p>

<dt><a name="outfile_=&#62;_$file"
>outfile =&#62; $file</a></dt>

<dd>
<p>A destination of the messages.</p>

<dt><a name="onlyerr_=&#62;_1_|_0"
>onlyerr =&#62; 1 | 0</a></dt>

<dd>
<p>It influences where the method <code>out()</code> prints its messages. If <code>onlyerr</code> is set to 1 (default is 0) only the erroneous messages will be sent to STDOUT. Here are various combinations of <code>outfile</code> and <code>onlyerr</code> arguments:</p>

<pre>   outfile    onlyerr    what will be done
   --------------------------------------------
   yes        no         all output to file

   yes        yes        all output to file
                         + errors also on STDOUT

   no         no         all output to STDOUT

   no         yes        only errors to STDOUT
   ---------------------------------------------</pre>

<dt><a name="format_=&#62;_tsv_|_human_|_html"
>format =&#62; tsv | human | html</a></dt>

<dd>
<p>How to format output messages. Default is <code>human</code>. The list of actually supported formats can be obtained by calling a class method <code>Monitor::Simple::Output-&#62;list_formats()</code>.</p>

<dt><a name="cssurl_=&#62;_$url"
>cssurl =&#62; $url</a></dt>

<dd>
<p>Used only for <code>html</code> format . It points to a URL with the CSS-stylesheet for the output. By default, it uses stylesheet similar to the one shown in the distribution in file <em>Monitor/Simple/configs/monitor-default.css</em>.</p>
</dd>
</dl>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="list_formats"
>list_formats</a></h3>

<p>A class method. It returns a hashref with a list of actually supported formats (keys) and their description (values). At the time of writing this document, it returns:</p>

<pre>   { tsv    =&#62; &#39;TAB-separated (good for machines)&#39;,
     human  =&#62; &#39;Easier readable by humans&#39;,
     html   =&#62; &#39;Formatted as an HTML document&#39; }</pre>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="out_($service_id,_$code,_$message)"
>out ($service_id, $code, $message)</a></h3>

<p>It formats and outputs one message about a just finished service check (with an additional date field). $service_id defines what service is the report about, $code indicates what kind of message is being outputted (see $Monitor::Simple::RETURN* constants) and $msg is the real message.</p>

<p>This method outputs one message, nothing before and nothing after it. Because some formats needs also a header and possible a footer, there are also methods <code>header</code> and <code>footer</code>.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="header_([$header])"
>header ([$header])</a></h3>

<p>It outputs a header line (in the format specified in the <code>new()</code> constructor). The content of the header is either taken from the $header argument or a default one is used.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="footer_([$footer])"
>footer ([$footer])</a></h3>

<p>It outputs a footer line (in the format specified in the <code>new()</code> constructor). The content of the footer is either taken from the $footer argument or a default one is used.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Monitor::Simple::Notifier"
>Monitor::Simple::Notifier</a></h2>

<p>This module is responsible for deciding whether a notification should be sent and for sending it. The main method is <code>notify()</code> that actually does first the decision if the notification should be sent and then sending it using its own <code>outputter</code>, an instance of <i>Monitor::Simple::Output</i>.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="new_(%args)"
>new (%args)</a></h3>

<p>It creates an instance (an <i>outputter</i>) with the given arguments. The recognized keys are:</p>

<dl>
<dt><a name="config_=&#62;_$config"
>config =&#62; $config</a></dt>

<dd>
<p>A configuration - the only mandatory argument. Actually, so far, the only argument.</p>
</dd>
</dl>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="notify_($result)"
>notify ($result)</a></h3>

<p>Given a $result of a service check, it makes all expected notifications (as defined in the $config given in the <code>new()</code> constructor). The $result is a hashref with this content:</p>

<pre>   { service =&#62; $service_id,
     code    =&#62; $code,
     msg     =&#62; $msg }</pre>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Monitor::Simple::Log"
>Monitor::Simple::Log</a></h2>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="log_init_($logging_options)"
>log_init ($logging_options)</a></h3>

<p>It initiates logging (using the <i>Log::Log4perl</i> module). $logging_options is a hashref with the keys <code>level</code>, <code>file</code> and <code>layout</code> (some or all keys may be missing). The level is a (case-insensitive) text acceptable by the method <code>Log::Log4perl::Level::to_priority()</code>: <code>debug</code>, <code>info</code>, <code>warn</code>, <code>error</code> or <code>fatal</code>. The file is where the log will be created to. Value STDOUT is also accepted. Finally, the layout is a format of the log messages as defined by in Log::Log4Perl; default value being</p>

<pre>   %d (%r) %p&#62; %m%n</pre>

<p>When writing a plugin or a notifier, this method is called for you automatically from the <a href="#parse_plugin_args_(%24default_service_id%2C_%40args)" class="podlinkpod"
>parse_plugin_args()</a> or <a href="#parse_notifier_args_(%40args)" class="podlinkpod"
>parse_notifier_args()</a>.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="get_logging_options"
>get_logging_options</a></h3>

<p>It returns currently used logging options - in the same format as the same options are define in <a href="#log_init_(%24logging_options)" class="podlinkpod"
>log_init()</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Monitor::Simple::Utils"
>Monitor::Simple::Utils</a></h2>

<p>This module is a container for various methods that did not fit elsewhere. There are no instances of this module (no <code>new</code> or similar method), all methods are class methods (but still methods - so use &#34;Monitor::Simple::Util-&#62;&#34; to call them).</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="parse_plugin_args_($default_service_id,_@args)"
>parse_plugin_args ($default_service_id, @args)</a></h3>

<p>It reads plugin&#39;s command-line arguments @args. It returns two-element array with the configuration file name (may be undef) and service ID (if the service id is found in @args, it uses $default_service_id). It uses logging options (if any found in @args) to set the logging system. Read about possible arguments in @args in <a href="#Plugins" class="podlinkpod"
>&#34;Plugins&#34;</a>.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="report_and_exit_($service_id,_$config,_$exit_code,_$return_msg)"
>report_and_exit ($service_id, $config, $exit_code, $return_msg)</a></h3>

<p>It prints $return_msg on the STDOUT and exits with the $exit_code. $config is not used (at least now) and can be undef. This method is usually the last call in your plugin.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="exec_or_exit_($service_id,_$config)"
>exec_or_exit ($service_id, $config)</a></h3>

<p>It executes an external program with the given arguments and (optionally) checks its STDOUT for the given content. If everything okay it just returns. Otherwise, it exits with the Nagios-compliant reporting (see more about it in <a href="#report_and_exit_(%24service_id%2C_%24config%2C_%24exit_code%2C_%24return_msg)" class="podlinkpod"
>report_and_exit()</a>).</p>

<p>This method uses <code>prg-test</code> portion of this service configuration.</p>

<h3><a class='u' href='#___top' title='click to go to top of document'
name="parse_notifier_args_($args)"
>parse_notifier_args ($args)</a></h3>

<p>It reads plugin&#39;s command-line arguments $args (an arrayref - so the recognized arguments can be removed from the provided array). It returns a three-element array with a service ID, a file name with the notification message and a reference to an array with all email addresses (may be empty for some notifiers). It uses logging options (if any found in $args) to set the logging system. Read about possible arguments in $args in <a href="#Notifiers" class="podlinkpod"
>&#34;Notifiers&#34;</a>.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="BUGS"
>BUGS</a></h1>

<p>Please report any bugs or feature requests to <a href="http://github.com/msenger/Monitor-Simple/issues" class="podlinkurl"
>http://github.com/msenger/Monitor-Simple/issues</a>.</p>

<h2><a class='u' href='#___top' title='click to go to top of document'
name="Known_bugs_and_limitations"
>Known bugs and limitations</a></h2>

<dl>
<dt><a name="Locking_remote_files"
>Locking remote files</a></dt>

<dd>
<p>The <i>copy-to-file</i> notifier adds notification messages to a file on a remote machine (if it is configured to use SSH) and it does it without any concern about the potential need of exclusively locking that file (it may be accessed in the same time by many notifiers). It is this way because it uses program &#34;cat&#34; which, as far as I know, does not do locking.</p>

<p>Similarly, log files are not using any locking.</p>
</dd>
</dl>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="ACKNOWLEDGMENT"
>ACKNOWLEDGMENT</a></h1>

<p>Thanks to Gisbert W. Selke <code>&#60;gws@cpan.org&#62;</code> the tests should be now working also under Windows. He also provided a new version of the <code>check_mem.pl</code> - under the name <i>check_mem2.pl</i> - a plugin, that should work both under Windows and Unix.</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="AUTHOR"
>AUTHOR</a></h1>

<p>Martin Senger &#60;martin.senger@gmail.com&#62;</p>

<h1><a class='u' href='#___top' title='click to go to top of document'
name="COPYRIGHT_AND_LICENSE"
>COPYRIGHT AND LICENSE</a></h1>

<p>This software is copyright (c) 2013 by Martin Senger, CBRC-KAUST (Computational Biology Research Center - King Abdullah University of Science and Technology) All Rights Reserved.</p>

<p>This is free software; you can redistribute it and/or modify it under the same terms as the Perl 5 programming language system itself.</p>

<!-- end doc -->

</body></html>
